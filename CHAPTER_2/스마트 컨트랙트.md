# 📝 2. 스마트 컨트랙트 📝

</br>

## 목차

1. [스마트 컨트랙트의 개념](#1-스마트-컨트랙트-개념)
    - [비트코인 트랜잭션 vs 스마트 컨트랙트 트랜잭션](#11-비트코인-트랜잭션과-스마트-컨트랙트-트랜잭션)
    - [기능](#12-스마트-컨트랙트의-기능)
2. [스마트 컨트랙트의 설계](#2-스마트-컨트랙트의-설계)
    - [유스케이스 다이어그램](#21-카운터를-위한-유스-케이스-다이어그램)
    - [설계 원칙 3](#22-데이터-애셋-피어-참여자-역할-규칙-그리고-트랜잭션)
    - [설계 원칙 4](#23-클래스-다이어그램에서-컨트랙트-다이어그램으로)
3. [스마트 컨트랙트 코드](#3스마트-컨트랙트-코드-작성)
    - [솔리디티 언어란 ?](#31-솔리디티-언어)
    - [코드](#32-카운트를-위한-스마트-컨트랙트-코드)
4. [스카이 컨트랙트 코드 배포 및 테스트](#4-스카트-컨트랙트-코드-배포-및-테스트)
    - [리믹스 IDE란 ?](#41-리믹스-ide)
    - [배포 & 테스팅](#42-배포와-테스팅)
5. [블록체인 컨트랙트](#5-블록체인-컨트랙트)
    - [Accounts Demo](#테스트)

</br>

### 🔎 목표

- 스마트 컨트랙트 이해하기
- 스마트 컨트랙트 개발을 위한 설계 원칙 적용하기
- 솔리디티 언어를 사용해 컨트랙트 코딩하기
- 리믹스 IDE를 사용해 스마트 컨트랙트를 작동시키고 트랜잭션을 처리해 보기
- 두 가지 유스 케이스를 위한 스마트 컨트랙트를 설계, 개발, 배포, 테스팅해 보기

</br>

## 용어

- 스마트컨트랙트(smart contract) : 애플리케이션의 규칙과 규정들을 디지털로 정의하고, 검증하고, 검사하며, 강제하기 위한 블록체인에서 작동시킬 수 있는 실행 가능한 코드다. 신뢰할 수 있는 트랜잭션의 수행ㅇ르 지웒나다. 이런 트랜잭션은 추적 기능하고 되돌릴 수 없다.
- [쿼럼(Quorum)](http://wiki.hash.kr/index.php/%EC%BF%BC%EB%9F%BC) : 블록체인 시스템에서 합의를 이루기 위한 최소한의 투표수를 가진 소그룹을 말한다.
- [코다(Corda)](http://wiki.hash.kr/index.php/%EC%BD%94%EB%8B%A4) : 세계 최대의 블록체인 컨소시엄인 R3가 만든 분산원장 기술이다.
- 하이퍼레저 : 스마트 계약을 구현할 수 있는 오픈소스 기반의 프라이빗 블록체인 프로젝트이다. 
- EOA : 외부소유계정(External Owned Account)으로 지갑(CA)보다 상위계정이다. 
- CA : 계약계정(Contract Account)은 스마트컨트랙트 역할 기능을 하며 배포된 코드와 저장공간이 추가로 존재한다. 
- [이더리움 계정과 트랜잭션에 대해](https://jojuim.tistory.com/entry/%EA%B8%B0%EB%B3%B8-%EC%9D%B4%EB%8D%94%EB%A6%AC%EC%9B%80-%EA%B3%84%EC%A0%95%EA%B3%BC-%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98-CA-EOA-TX-%EB%93%9C)

</br>

## 1. 스마트 컨트랙트 개념

스마트 컨트랙트는 비트코인 블록체인 프로토콜이 제공했던 기본적인 신뢰를 확장시키는 코드이다. 디지털 자산을 위한 트랜잭션을 지원할 수 있는 프로그래밍을 가능하게 해준다. 또한 애플리케이션이 필요로 하는 특정한 확인과 검증을 가능하게 한다.

- 블록체인 애플리케이션 스택과 레이어
<img src="https://user-images.githubusercontent.com/68188768/166471469-f49aba9e-ecf4-4c0e-9b28-951d3da60441.png">
### 1.1 비트코인 트랜잭션과 스마트 컨트랙트 트랜잭션

<img src="https://user-images.githubusercontent.com/68188768/166471983-92ccfce3-9803-4225-b1ee-1cb2371d862b.png">

1. 비트코인
    - 모든 트랜잭션은 가치(Tx(sendValue))를 전송하기 위한 것이다.
    - 오직 암호 화폐의 전송을 위한 트랝개션만을 지원한다.
2. 스마트 컨트랙트
    - 트랜잭션은 스마트 컨트랙트가 구현한 기능을 임베디드한다.
    - 어떠한 애플리케이션 로직도 지원할 수 있다.
    - 예) 투표 애플리케이션을 위한 트랜잭션


이러한 임의적인 코드를 올리고 실행할 수 있는 기능은 암호 화폐 전송을 넘어서서 블록체인의 활용도를 크게 향상시킨다.

### 1.2 스마트 컨트랙트의 기능

스마트 컨트랙트는 블록체인 애플리케이션의 두뇌와 같은 역할을 한다. 주요 기능으로는 다음과 같다.
- 특수한 조건에 맞는 <strong>확인과 검증</strong>을 할 수 있는 비즈니스 로직 레이어를 표현.
- 탈중앙화 네트워크에서 자산의 전송을 위한 <strong>정책</strong>을 구현하기 쉽도록 한다.
- <strong>규칙</strong>의 명세를 설정할 수 있게 한다.
- <strong>함수를 내장</strong>하며 추가적인 <strong>메타 데이터</strong>를 포함한다.
- 탈중앙화 블록체인 기반 애플리케이션을 위한 <strong>소프트웨어 기반 중개자</strong>로서 기능한다.
- 블록체인에 <strong>프로그래밍 기능성과 지능성</strong>을 제공한다.
- 탈중앙화 블록체인 애플리케이션의 중심 컴포넌트이다.

</br>

## 2. 스마트 컨트랙트의 설계

- 설계원칙

1. 테스트 체인에서 스마트 컨트랙트를 코딩, 개발, 배포하기 전에 우선 설계부터 한다. 또한 사마트 컨트랙트는 변조 불가능 하기 때문에 프로덕션 블록체인에 배포하기 전에 철저한 테스트를 거쳐야 한다.
2. 시스템 사용자와 유스 케이스를 정의한다. 사용자란 행위와 입력값을 발생시키고, 설계하고 있는 해당 시스템으로부터 그 출력값으로 받는 주체다.
3. 데이터 애셋, 피어 참여자, 그들의 역할, 강제할 규칙, 설계하고 있는 시스템에 기록해야 할 트랜잭션을 정의한다.
4. 컨트랙트 이름, 데이터 애셋, 함수, 함수의 실행과 데이터 접근을 위한 규칙을 정의하는 컨트랙트 다이어그램을 작성한다.

설계원칙과 관련된 내용을 예제를 이용해서 자세히 다뤄보도록 한다.

<strong> 예제 1) 탈중앙화 카운터 </strong>

탈중앙화 카운터는 일상 애플리케이션에서 공통으로 사용한다.
- 예)

|시스템 타입|카운터 예|
|:---|:---|
|수동시스템|놀이공원의 입출입자 집계를 윟나 회전식 개찰구|
|중앙화 시스템|주식 인덱스|
|분산 시스템|국가 무역 적자|
|탈중앙화 시스템|세계 인구|

트랜잭션을 통해 스마트 컨트랙트를 블록체인에 배포하는데, 블록의 일부분에 포함됨으로써 블록체인에 영구히 기록되고, 되돌릴 수 없으며, 수정할 수 없다.

### 2.1 카운터를 위한 유스 케이스 다이어그램

유스 케이스와 클래스 다이어그램을 보여주기 위해 표준적인 통합 모델 언어[UML](https://www.uml.org/index.html)를 사용한다. UML을 이용하게 되면 해결해야 할 문제와 함수들을 어떻게 사용해야 할지에 대해 숙고할 수 있도록 해준다.

- 카운터를 위한 유스 케이스

<img src="https://user-images.githubusercontent.com/68188768/166472358-05af9910-3b5a-4452-93f0-f4513131e83d.png">

- initialize() : 값에 대한 초기화
- increment() : 주어진 값만큼 증가
- decrement() : 주어진 값만큼 감소
- get() : 카운터값을 가져오기

이 단계에서 만든 설계 내용이 해결해야 하는 문제에는 종속적이지만, 특정한 코딩 또는 시스템에는 종속적이지 않다.

### 2.2 데이터 애셋, 피어 참여자, 역할, 규칙, 그리고 트랜잭션

유스 케이스 다이어그램에서 정의한 함수들을 사용할 주체와 그 규칙이 무엇인지를 정해야 한다. 블록체인 기반 컴포넌트들의 여러 속성에 대해 설명할 것이다.

탈중앙화 카운터 문제에서 설계 원칙 3을 적용하면 다음과 같은 아이템을 설정할 수 있다. 

- 추적해야 할 데이터 애셋 : 카운터의 값
- 피어 참여자 : 카운터 값을 업데이트 할 애플리케이션
- 참여자의 역할 : 카운터값을 업데이트하고 그 값에액세스하는 것
- <i>데이터와 함수에 검증, 검사해야 할 규칙 (현재 예제 유스케이스에는 없음)</i>
- 디지털 정부에 기록해야 하는 트랜잭션 : initialize(), increment(), decrement()

즉, 카운터값을 바꾸는 함수나 트랜잭션만을 기록하면 된다. 스마트 컨트랙트에 정의된 모든 함수가 블록체인의 분산 정부에 기록을 남기는 트랜잭션을 생성하는 것은 아니다. 현재 예제에서 get() 함수는 <strong>읽기 전용 함수로 정의할 수 있다. 읽기 전용 함수의 실행은 블록체인에 기록하지 않는다.</strong>

### 2.3 클래스 다이어그램에서 컨트랙트 다이어그램으로

유스 케이스와 디지털 애셋 분석에서 나온 아이템들을 바탕으로 클래스 다이어그램을 그린다. <strong>OOP의 전형적인 UML 클래스 다이어그램은 클래스의 이름, 데이터 정의, 함수 정의 세 가지 요소를 포함한다.</strong>

- 클래스 다이어그램과 컨트랙트 다이어그램 템플릿 비교

<img src="https://user-images.githubusercontent.com/68188768/166474543-07b52aa0-9864-4a8b-872b-358b8439d152.png">

스마트 컨트랙트 다이어그램은 함수와 데이터에 대한 접근 규칙 컴포넌트를 추가적으로 가지고 있다.

- 카운터 컨트랙트 다이어그램

<img src="https://user-images.githubusercontent.com/68188768/166480780-a56a1183-42b6-4a3f-82d4-8af0fd8208a5.png">

이 다이어그램에서 컨트랙트의 여러 가지 요소(데이터 변수와 함수)의 구분자로 캠러 케이스 양식을 사용했다. constructor()함수는 스마트 컨트랙트가 블록체인 인프라에서 작동하는 VM 샌드박스에 처음 배포되었을 때 한 번만 작동한다. 일반 객체지향 클래스 설계와 크게 다르지 않다. [diagrams.net](https://www.diagrams.net)을 사용해서 그리거나 익숙한 다른 UML을 사용하면 된다.

</br>

## 3. 스마트 컨트랙트 코드 작성

스마트 컨트랙트 개발을 위해서는 블록체인 오퍼레이션에 특화된 전용언어가 필요하다.예제는 솔리디티를 사용하도록 한다. 솔리디티는 이더리움 재단이 처음 도입했는데, 하이퍼레저와 같은 다른 블록체인 플랫폼도 이를 사용한다.

컨ㅌ느랙트 코드를 작성하는 것은 블록체인 기반의 기록을 위해 정밀한 명령을 만드는 것이다. 다만 어카운트 주소, 규칙 사용, 트랜잭션 되돌림과 같은 블록체인에 특화된 특정 기능이 언어에 내장되어 있어야 한다. 또한, 스마트 컨트랙트 코드는 여러 블록체인 코드에서 실행될 때 일관성을 유지하기 위해 제한된 샌드박스 환경에서 실행된다. 

### 3.1 솔리디티 언어

솔리디티 언어는 고수준 언어로 C++, 파이썬, 자바스크립트 등의 영향을 받았다. 정접 타입 언어이며 상속, 라이브러리, 사용자 정의 타입 등을 지원한다. 

### 3.2 카운트를 위한 스마트 컨트랙트 코드

- 리믹스 IDE 사용

1. 브라우저에서 리믹스 IDE를 오픈한다. [바로가기](https://remix.ethereum.org/)
2. 솔리디티 언어를 선택한다(바이퍼는 스마트 컨트랙트를 위한 또 하나의 언어이다.)
3. IDE에서 왼쪽 패널 맨 위에 있는 아이콘을 클릭해서 새 파일을 만든다.
4. 열른 팝업 윈도우에서 Counter.sol이라고 이름을 설정한다.
5. 코드를 작성한다.

- 코드작성

```
pragma solidity ^0.6.0; // 사용한 언어의 버전을 지정 필수
contract Counter {
    uint value; // 카운터값을 위한 공유 데이터
    function initialize (uint x) public {
        value = x;
    }
    
    function get() view public returns (uint) {
        return value;
    }

    function increment (uint n) public {
        value = vlaue + n;
        // return (optional)
    }

    function decrement (uint n) public {
        value = value - n;
    }
}
```

- prama solidity ^<u>version</u> : 사용한 언어의 버전과 컴파일할 때 사용할 버전을 일치시키기 위해서 버전을 지정한다.
- parama 지시문을 사용하며 0.6.0 버전ㅇ르 사용했다.
- 지시문 이후 contract 키워드와 컨트랙트의 이름으로 컨트랙트 코드 정의를 한다.
- 버전을 변경하게 된다면 일부 코드 수정이 필요할 수도 있게된다.
- uint : 데이터 타입을 카운터 값ㅇ르 지정하는 식별자를 정의하기 위해 사용. 솔리디티의 경우 64비트가 아닌 256비트 값이다.
- uint, int, int256, uint256은 모두 같은 값의 별칭이다.
- 명시적인 생성자 함수를 정의하고 있지 않을 때는 기본 생성자가 컨트랙트를 배포하기 위해 사용한다.
- public : 공개적 가시성을 가진다. 즉, 블록체인상에 있는 어떠한 외부의 참여자(또는 어카운트)도 이 함수를 호출할 수 있다는 것을 의미한다.
- return : 함수 호출의 결과로 반환될 값을 명시적으로 정의할 수 있다.
- get() 함수를 제외한 함수들은 본문 안에서 변수 value를 갱신하는 역할을 하며 자동적으로 value의 상태 변화 또는 모두 각각 분산 장부상의 트랜잭션으로 기록된다.
- view : 블록체인상에 기록되지 않으며 카운터 값 상태를 변화시키지 않는다.

</br>

## 4. 스카트 컨트랙트 코드 배포 및 테스트

### 4.1 리믹스 IDE

리믹스는 별도의 설치 과정 없이 웹/클라우드 기반으로 통합 개발 환경을 제공한다. 그뿐만 아니라 자바스크립트 기반의 테스트 체인 환경을 제공하고, 작성한 컨트랙트 코드를 이 체인 윙 ㅔ바로 배포해서 생성할 수 있도록 지원해준다. 이 일체형의 개발 환경에서 테스트한 스마트 컨트랙트 코드는 리믹스 테스트 체인뿐만 아니라 외부 블록체인으로도 쉽게 배포할 수 있다.

### 4.2 배포와 테스팅

- 배포

1. 컴파일

<img src="https://user-images.githubusercontent.com/68188768/166491663-0e4ebfdf-b85e-4f59-8a6c-e2096d91b5fe.png">

    - 작성한 버전에 맞춰서 컴파일 할 버전을 선택한다.
    - 자동 컴파일 체크하면 이 단계를 진행하지 않을 수 있다.
    - 컴파일 버튼을 클릭한다.

2. 배포 및 트랜잭션 실행 환경 체크

<img src="https://user-images.githubusercontent.com/68188768/166492349-98effbf9-f81b-4df3-8806-d86fc42cfe18.png">

    - 자바스크립트 VM으로 설정되어 있는지 확인

3. 배포

<img src="https://user-images.githubusercontent.com/68188768/166493063-8e0690a2-7034-48f1-a130-06f9dfe90879.png">

    - 배포버튼을 클릭한다. 이후 Deployed Contracts에서 작동을 관찰한다.

- 테스팅 결과

<img src="https://user-images.githubusercontent.com/68188768/166491131-ecfa1c5c-9573-48ed-a5a3-b36428a2a7c0.png">

### 4.3 정리

- 스마트 컨트랙트 코드를 블록체인에 배포하였을 대 블록체인에 정의된 아이덴티티를 가진 누구나 접근 가능하다.
- 어카운트 번호를 가지고 있고 동일한 블록체인 네트워크에 접속해 있다면 누구나 동일하게 이 컨트랙트를 사용할 수 있다.
- 분산 시스템은 변조 불가능한 분산 장보를 사용하지 않는 다는 것이 가장 큰 차이점이다.
- 모든 참여자는 해당 스마트 컨트랙트상에 일어난 모든 트랜잭션 리승트와 동일한 카피를 가지게 된다.
- 탈중앙화 참여 노드 간에 신뢰를 구축하고, 혁신적인 Dapp을 위한 새로운 차원의 기회를 제공해 준다.

</br>

## 5. 블록체인 컨트랙트

스마트 컨트랙트는 블록체인 네트워크의 다른 참여자와 동등한 지위를 갖는데, 스마트 컨트랙트가 다음과 같은 속성을 갖고있기 때문이다.

- 이름
- 주소
- 암호 화폐 잔액
- 암호 화폐를 송금하고 수신할 수 있는 내장 기능
- 데이터 함수
- 메시지를 쉰하고 함수를 호출할 수 있는 내장 기능
- 함수 실행을 계산할 수 있는 능력

블록체인과 상호작용을 하는 모든 참여자는 고유하게 식별 가능한 어카운트 번호(주소)를 가진다. 이더리움은 두 가지 종류의 어카운트가 있다.

    외부 소유 어카운트 (externally owned accounts, EOA)
    스마트 컨트랙트 어카운트 (smart contract accounts, SCA)

두 어카운트 모두 160비트 또는 20바이트 크기의 주소로 식별한다. 또한 모두 이더 밸런스를 가질 수 있어 모든 어카운트는 address와 balance라는 묵시적 속성을 가진다.

    address(this).balance

메시지를 보냄으로써 함수를 호출 할 수 있는데 메시지는 두 가지의 묵시적 속성을 가지고 있다.

    msg.sender
    msg.value

호출한 스마트 컨트랙트의 함수를 실행할 때 그 금액은 호출한 스마트 컨트랙트의 밸런스에 더해진다. 이렇게 금액을 전송받기 위해서는 해당 함수에 payable 수정자(modifier)를 포함해 선언해야 한다.

- 예 2) AccountsDemo.sol
```
pragma solidity ^0.6.0;
contract AccountsDemo {

    address public whoDeposited;
    uint public depositAmt;
    uint public accountBalance;

    // 페이먼트를 수신할 수 있다 (payable)
    function deposit() public payable {
        whoDeposited = msg.sender; // 모든 함수 호출은 msg.sender라는 내포적 속성을 가진다.
        depositAmt = msg.value; // 모든 함수 호출은 msg.sender가 보내는 msg.value를 전송할 수 있다.
        accountBalance = address(this).balance;
    }
}
```

#### 테스트

<img src="https://user-images.githubusercontent.com/68188768/166501846-dbdf2137-ce7c-4a1a-a1d9-e041c01769b4.png">

    - 배포를하면 Account가 추가된다. 
    - 이후 value 값을 변경하며 테스트를 한다.

</br>

<img src="https://user-images.githubusercontent.com/68188768/166502450-ed8e9452-c6e6-4091-9ec4-db66069a6488.png">

    deposit 버튼을 눌러 변경한 value값을 적용 시킨다.
    whoDeposited의 주소 값에 따라 value 값이 depositAmt와 accountBalance에 적용되는 것을 볼 수 있다.
    (value를 10으로 2번 적용했을 때 사진이다.)

스마트 컨트랙트가 자율적으로 암호 화폐를 받고, 저장하고, 보내는 것을 확인할 수 있다. 이러한 스마트 컨트랙트의 특수한 특성이 새로운 기회의 세계를 열어준다고 한다.

</br>

## 6. 탈중앙화 항공사 시스템 유스케이스

서로 다른 어카운트 타입의 차이를 살펴보며 블록체인에 저장할 정보량을 최소화할 수 있어야한다.

- 예 3) 항공사 시스템 컨소시엄
    - 항공사 간에 좌석의 P2P 트랜잭션을 가능케 해주는 시스템
    - ASK는 서로 코드를 공유하지 않은 항공사들이 좌석을 P2P로 거래할 수 있는 시장

### 6.1 ASK 란

- 가상 시나리오

항공사의 중앙화된 분산 시스템을 개선하려고 한다고 가정한다. 항공사들은 허가형이며 탈중앙화 컨소시엄에 참여할 수 있다고 가정한다. 이 컨소시엄을 ASK라고 부른다.

- 기능
    - 항공사는 언제든지 원하는 바에 따라 합류하거나 탈퇴할 수 있다.
    - ASK 트랜잭션에서 좌석의 정산에 상ㅇ도리 미리 설정된 최소 에스크로 금액을 예치하여 ASK에 합류할 수 있다.
    - 항공사 간 좌석을 트레이딩 할 수 있게 허용한다.
    - 트레이딩 규칙은 코드에 포함되어 있으며 애매모호한 경우는 없고 모든 결과가 결정론적이다.

- ASK 사분면 차트 : 유스 케이스 이슈, 블록체인 솔루션, 혜택에 대해

<img src="https://user-images.githubusercontent.com/68188768/166504504-6eb47edb-1b52-464f-b75d-28d93331a208.png">

비행기편을 조회하는 것과 유사하게 보이지만, 소프트웨어 애플리케이션에 의해 프로그래밍적으로 호출되며, 중개자가 필요없다는 차이가 있다. 애플리케이션의 요청은 직접 항공사로 보내진다.

- 탈중앙화 항공사 시스템에서 참여자의 오퍼레이션

<img src="https://user-images.githubusercontent.com/68188768/166504960-39df4030-d40a-4aa6-b0e6-0028d623169e.png">

1. 고객이 항공사 A에 예약했던 좌석 변경 요청
2. 항공사는 ASK 컨소시엄 회원들에게 공유된 스마트 컨트랙트 로직을 이용하여 요청 확인 및 검증
3. 확인 후 Tx는 컴펌되고 변조 불가능한 분산 장부에 기록된다. 정당한 요청이 생성됨을 알 수 있음.
4. 항공사 A의 에이전트가 확인 및 검증된 요청(VVrequest)을 항공사 B에게 보낸다.
5. 항공사 B는 애플리케이션 및 에이전트를 사용 DB를 검색하여 가용성을 확인
6. 항공사 B는 컨소시엄의 공동 이해관계와 공유된 규칙을 확인하고 검증하는 공유 스마트 컨트랙트 로직ㅇ르 통해 응답
7. 확인후 응답 Tx는 컨펌되고 변조 불가능한 분산 장부에 기록되어 모든 참여자가 응답을 보낸 것을 알 수 있다.
8. 항공사 B는 이 응답을 항공사 A의 에이전트에게 보낸다.
9. 항공사 A는 자기의 데이터베이스를 업데이트하고 변화된 것을 기록한다.
10. 항공사 B의 에이전트는 고객에게 좌석과 기타 상세 정보를 보낸다.
11. 정보를 공유하고 있는 스마트 컨트랙트에 에스크로해 두었다가, 예치했던 금액을 이용한 P2P 트랜잭션을 통해 정산한다. 이후 장부에 기록한다.

## 7. 항공사 스마트 컨트랙트

설계원칠에 따라 설계를 시작한다. 

### 7.1 설계 원칙 2

- ASK 유스 케이스와 컨트렉트 다이어 그램

<img src="https://user-images.githubusercontent.com/68188768/166506006-5d9c6bb0-ca7f-47b2-847d-a4c339d03cba.png">

### 7.2 설계 원칙 3

- 피어 참여자, 데이터 애셋, 역할, 트랜잭션, 규칙

1. 피어참여자 : 에이전트
2. 데이터 애셋
3. 역할 
4. 트랜잭션
5. 규칙

### 7.3 항공사 스마트 컨트랙트 코드

```
pragma solidity ^0.6.0;
contract Airlines {
    address chairperson;
    // 항공사 데이터 구조
    struct details {
        uint escrow; // 지불 정산을 위한 예치
        uint status;
        uint hashOfDetails;
    }
    
    // 항공사 어카운트 페이먼트와 회원 매칭
    mapping (address=>details) public balanceDetails; 
    mapping (address=>uint) membership;

    // 수정자 또는 규칙들
    modifier onlyChairperson {
        require(msg.sender==chairperson);
        _;
    }
    modifier onlyMember {
        require(membership[msg.sender] == 1);
        _;
    }

    // 생성자 함수; payable 함수를 위한 msg.sender와 msg.value사용
    constructor() public payable {
        chairperson=msg.sender;
        membership[msg.sender] = 1; // 자동으로 등록
        balanceDetails[msg.sender].escrow = msg.value;
    }

    function register() public payable {
        address AirlineA = msg.sender;
        membership[AirlineA] = 1;
        balanceDetails[msg.sender].escrow = msg.value;
    }

    function unregister(address payable AirlineZ) onlyChairperson public{
        membership[AirlineZ] = 0;
        // 출발 항공사에게 에스크로를 반환: 다른 조건들 확인
        AirlineZ.transfer(balanceDetails[AirlineZ].escrow);
        balanceDetails[AirlineZ].escrow = 0;
    }

    function request(address toAirline, uint hashOfDetails) onlyMember public {
        if (membership[toAirline] != 1) {
            revert();
        }
        balanceDetails[msg.sender].status = 0;
        balanceDetails[msg.sender].hashOfDetails = hashOfDetails;
    }

    function response(address fromAirline, uint hashOfDetails, uint done) onlyMember public {
        if (membership[fromAirline] != 1) {
            revert();
        }
        balanceDetails[msg.sender].status = done;
        balanceDetails[fromAirline].hashOfDetails = hashOfDetails;
    }

    function settlePayment(address payable toAirline) onlyMember payable public {
        address fromAirline = msg.sender;
        uint amt = msg.value;

        balanceDetails[toAirline].escrow = balanceDetails[toAirline].escrow + amt;
        balanceDetails[fromAirline].escrow = balanceDetails[fromAirline].escrow - amt;

        // msg.send로 부터 amt를 차감해 toAirline에게 보냄
        // 외부 어카운트로 금액을 전송하는 스마트 컨트랙트 어카운트
        toAirline.transfer(amt);
    }
    
}
```

- address : 의장(chairperson)의 아이덴티티
- struct : 에스크로 또는 예치금을 포함한 항공사의 데이터를 집합적으로 정의
- mapping : 회원의 어카운트 주소(아이덴티티)를 그들의 상세 정보에 매핑(해시 테이블과 유사)
- modifier : memberOnly와 chairpersonOnly를 정의